package go_conv

import (
	"fmt"
	"go-conv/testdata/domain"
	"go-conv/testdata/model"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"testing"
	"unicode"

	"golang.org/x/tools/go/packages"
)

// go-conv:generate
var ModelToDomain func(*model.Pet) *domain.Pet

//go:generate
type MethodAndDoc struct {
	Src, Dst types.Type
	Doc      *ast.CommentGroup
}

func Test(t *testing.T) {
	inputFile := "testdata/setup.go"
	absPath, err := filepath.Abs(inputFile)
	if err != nil {
		t.Fatalf("abs err:%v", err)
	}
	_, err = os.Stat(inputFile)
	if err != nil {
		t.Fatalf("inputFile:%s err:%v", inputFile, err)
	}
	const parserLoadMode = packages.NeedName | packages.NeedImports | packages.NeedDeps |
		packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo

	var srcAstFile *ast.File
	loadConf := &packages.Config{
		Mode: parserLoadMode,
		ParseFile: func(fset *token.FileSet, filename string, src []byte) (*ast.File, error) {
			//log.Printf("parse filename:%s", filename)
			if filename == absPath {
				r, e := parser.ParseFile(fset, filename, src, parser.SkipObjectResolution|parser.ParseComments)
				srcAstFile = r
				return r, e
			} else {
				return parser.ParseFile(fset, filename, src, parser.SkipObjectResolution)
			}
		},
	}

	initial, err := packages.Load(loadConf, "file="+inputFile)
	if err != nil {
		t.Fatal(err)
	}
	//t.Log(initial)
	//t.Log(srcAstFile)
	srcPackage := initial[0]
	var methods []MethodAndDoc

	for _, decl := range srcAstFile.Decls {
		// we only resolve the package level Decl
		if gd, ok := decl.(*ast.GenDecl); ok {
			var isTarget = false
			if gd.Doc == nil {
				continue
			}
			for _, comment := range gd.Doc.List {
				if strings.Contains(comment.Text, ":convergen") {
					isTarget = true
					break
				}
			}
			if !isTarget {
				continue
			}
			for _, spec := range gd.Specs {
				if ts, ok := spec.(*ast.TypeSpec); ok {
					tye := srcPackage.TypesInfo.TypeOf(ts.Type)
					if itye, ok := tye.(*types.Interface); ok {
						astMethods := ts.Type.(*ast.InterfaceType).Methods.List
						for i := range itye.NumMethods() {
							method := itye.Method(i)
							var md = MethodAndDoc{
								Src: method.Signature().Params().At(0).Type(),
								Dst: method.Signature().Results().At(0).Type(),
								Doc: astMethods[i].Doc,
							}
							methods = append(methods, md)
						}
					}
				}
			}
		}
	}
	var f = &ast.File{
		Name: &ast.Ident{
			Name: "test_gen",
		},
	}
	builder := &Builder{
		f:           f,
		types:       srcPackage.Types,
		importer:    NewImporter(),
		pkgPath:     srcPackage.PkgPath,
		genFuncName: map[string]struct{}{},
	}
	// parse method
	for _, method := range methods {
		builder.BuildFuncNew(method.Src, method.Dst)
	}
	// handle import
	builder.FillImport()
	var sb strings.Builder
	sb.WriteString("// Code generated by github.com/ycl2018/go-conv DO NOT EDIT.\n\n")
	err = printer.Fprint(&sb, token.NewFileSet(), f)
	if err != nil {
		t.Fatal(err)
	}
	t.Logf(sb.String())
}

func cleanName(name string) string {
	var s strings.Builder
	var first = true
	for _, c := range name {
		if unicode.IsLetter(c) || (unicode.IsNumber(c) && !first) {
			if first {
				s.WriteString(strings.ToUpper(string(c)))
				first = false
			} else {
				s.WriteRune(c)
			}
		}
	}
	return s.String()
}

func (b *Builder) GenFuncName(src, dst types.Type) string {
	srcTypeName, dstTypeName := b.importer.ImportType(src), b.importer.ImportType(dst)
	return cleanName(srcTypeName) + "To" + cleanName(dstTypeName)
}

func (b *Builder) BuildFuncNew(dst, src types.Type) {
	srcTypeName, dstTypeName := b.importer.ImportType(src), b.importer.ImportType(dst)
	funcName := b.GenFuncName(src, dst)
	b.genFuncName[funcName] = struct{}{}
	b.rootNode = true
	srcName, dstName := "src", "dst"
	// add a func
	fn := &ast.FuncDecl{
		Name: &ast.Ident{
			Name: funcName,
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("src")},
					Type:  ast.NewIdent(srcTypeName),
				},
			}},
			Results: &ast.FieldList{List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("dst")},
					Type:  ast.NewIdent(dstTypeName),
				},
			}},
		},
		Body: &ast.BlockStmt{},
	}
	b.f.Decls = append(b.f.Decls, fn)
	srcVar, dstVar := types.NewVar(0, b.types, srcName, src), types.NewVar(0, b.types, dstName, dst)
	stmts := b.buildStmt(dstVar, srcVar)
	fn.Body.List = append(fn.Body.List, stmts...)
	fn.Body.List = append(fn.Body.List, &ast.ExprStmt{X: ast.NewIdent("return")})

}

// Builder a file in a package
type Builder struct {
	f           *ast.File
	types       *types.Package
	importer    *Importer
	pkgPath     string
	genFuncName map[string]struct{}
	rootNode    bool
}

type Importer struct {
	pkgToName       map[string]string
	importedPkgName map[string]int
	imported        []*types.Package
}

func (i *Importer) ImportType(t types.Type) string {
	var pkgPath string
	var pkgName string
	var typeName string
	var typPrefix string
	var pkg *types.Package
	var resolve func(tye types.Type)
	resolve = func(tye types.Type) {
		switch varType := tye.(type) {
		case *types.Named:
			pkg = varType.Obj().Pkg()
			pkgPath = pkg.Path()
			pkgName = pkg.Name()
			typeName += varType.Obj().Name()
			return
		case *types.Basic:
			typeName += varType.Name()
		case *types.Slice:
			typPrefix += "[]"
			resolve(varType.Elem())
		case *types.Pointer:
			typPrefix += "*"
			resolve(varType.Elem())
		default:
			panic("expect unreachable")
		}
	}
	resolve(t)
	if pkgPath == "" {
		return typeName
	}
	pkgImportName := i.pkgToName[pkgPath]
	if pkgImportName == "" {
		pkgImportName = pkgName
		// import pkg name
		if num, ok := i.importedPkgName[pkgImportName]; ok {
			next := num + 1
			i.importedPkgName[pkgImportName] = next
			pkgImportName = pkgImportName + strconv.Itoa(next)
		} else {
			i.importedPkgName[pkgImportName] = 1
		}
		i.pkgToName[pkgPath] = pkgImportName
		i.imported = append(i.imported, pkg)
	}
	name := typPrefix + pkgName + "." + typeName
	return name
}

func NewImporter() *Importer {
	return &Importer{
		pkgToName:       map[string]string{},
		importedPkgName: map[string]int{},
	}
}

func convArrayToSlice(v types.Type) (s *types.Slice, conved, ok bool) {
	if s, ok = v.(*types.Slice); ok {
		return s, false, true
	}
	if arr, ok := v.(*types.Array); ok {
		return types.NewSlice(arr.Elem()), true, true
	}
	return nil, false, false
}

func convSliceToArray(v types.Type) (arr *types.Array, conved, ok bool) {
	if arr, ok = v.(*types.Array); ok {
		return arr, false, true
	}
	if s, ok := v.(*types.Slice); ok {
		// we can't define the length
		return types.NewArray(s.Elem(), -1), true, true
	}
	return nil, false, false
}

func convStructToPointer(v types.Type) (ptr *types.Pointer, conved, ok bool) {
	if ptr, ok := v.(*types.Pointer); ok {
		return ptr, false, true
	}
	// check if src is a Named struct
	if v, ok := v.(*types.Named); ok {
		if _, ok := v.Underlying().(*types.Struct); ok {
			return types.NewPointer(v), true, true
		}
	}
	return nil, false, false
}

func convPtrToStruct(v types.Type) (strut *types.Struct, conved, ok bool) {
	if strut, ok := v.(*types.Struct); ok {
		return strut, false, true
	}
	if ptr, ok := v.(*types.Pointer); ok {
		if named, ok := ptr.Elem().(*types.Named); ok {
			if strut, ok := named.Underlying().(*types.Struct); ok {
				return strut, true, true
			}
		}
	}
	return nil, false, false
}

func (b *Builder) buildStmt(dst *types.Var, src *types.Var) []ast.Stmt {
	defer func() {
		b.rootNode = false
	}()
	var stmts []ast.Stmt
	switch dstType := dst.Type().(type) {
	case *types.Pointer:
		srcPtrType, conved, ok := convStructToPointer(src.Type())
		if !ok {
			log.Printf("src type is not a pointer:%s", src.String())
			return append(stmts, buildCommentExpr("omit "+dst.Name()))
		}
		// check if has generated func
		if named, ok := dstType.Elem().(*types.Named); ok {
			if _, ok := named.Underlying().(*types.Struct); ok && !b.rootNode {
				funcName := b.GenFuncName(srcPtrType, dst.Type())
				convedSrcName := func() string {
					if conved {
						return "&" + src.Name()
					}
					return src.Name()
				}()
				assignStmt := &ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent(dst.Name())},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{&ast.CallExpr{
						Fun:  ast.NewIdent(funcName),
						Args: []ast.Expr{ast.NewIdent(convedSrcName)},
					}},
				}
				if _, ok := b.genFuncName[funcName]; !ok {
					b.BuildFuncNew(dst.Type(), srcPtrType)
				}
				stmts = append(stmts, assignStmt)
				return stmts
			}
		}
		ifStmt := &ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X: &ast.Ident{
					Name: src.Name(),
				},
				Op: token.NEQ,
				Y:  ast.NewIdent("nil"),
			},
			Body: &ast.BlockStmt{},
		}
		// dst = new(dst.Type)
		destPtr, srcPtr := dst.Type().(*types.Pointer), srcPtrType
		srcVarName := func() string {
			if conved {
				return src.Name()
			}
			return "*" + src.Name()
		}()
		dstElemVar := types.NewVar(0, b.types, "*"+dst.Name(), destPtr.Elem())
		srcElemVar := types.NewVar(0, b.types, srcVarName, srcPtr.Elem())
		initAssign := &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent(dst.Name())},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{&ast.CallExpr{
				Fun:  ast.NewIdent("new"),
				Args: []ast.Expr{ast.NewIdent(b.importer.ImportType(dstElemVar.Type()))},
			}},
		}
		ifStmt.Body.List = append(ifStmt.Body.List, initAssign)
		elementStmt := b.buildStmt(dstElemVar, srcElemVar)
		ifStmt.Body.List = append(ifStmt.Body.List, elementStmt...)
		stmts = append(stmts, ifStmt)
		return stmts
	case *types.Struct:
		srcType, _, ok := convPtrToStruct(src.Type())
		if !ok {
			log.Printf("src type is not a struct:%s", src.String())
			return append(stmts, buildCommentExpr("omit "+dst.Name()))
		}
		srcName := strings.TrimPrefix(src.Name(), "*")
		dstName := strings.TrimPrefix(dst.Name(), "*")
		for i := range dstType.NumFields() {
			dstField := dstType.Field(i)
			dstFieldName := dstField.Name()
			// match srcField
			var match bool
			for j := range srcType.NumFields() {
				srcField := srcType.Field(j)
				if srcField.Name() == dstFieldName {
					dstVarName := dstName + "." + dstFieldName
					srcVarName := srcName + "." + srcField.Name()
					dstVar := types.NewVar(0, b.types, dstVarName, dstField.Type())
					srcVar := types.NewVar(0, b.types, srcVarName, srcField.Type())
					fieldStmt := b.buildStmt(dstVar, srcVar)
					stmts = append(stmts, fieldStmt...)
					match = true
					break
				}
			}
			if !match {
				log.Printf("src field %s not found in struct:%s", dstFieldName, srcType.String())
				return append(stmts, buildCommentExpr("omit "+dstFieldName))
			}
		}
		return stmts
	case *types.Array:
		srcArrType, _, ok := convSliceToArray(src.Type())
		if !ok {
			log.Printf("src type is not a array/slice:%s", src.String())
			return append(stmts, buildCommentExpr("omit "+dst.Name()))
		}
		// for i := 0; i<n ; i++ {}
		forStmt := &ast.ForStmt{
			Init: &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("i")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{ast.NewIdent("0")},
			},
			Cond: &ast.BinaryExpr{
				X: &ast.BinaryExpr{
					X:  ast.NewIdent("i"),
					Op: token.LSS,
					Y:  ast.NewIdent(strconv.FormatInt(dstType.Len(), 10)),
				},
				Op: token.LAND,
				Y: &ast.BinaryExpr{
					X:  ast.NewIdent("i"),
					Op: token.LSS,
					Y: &ast.CallExpr{
						Fun:  ast.NewIdent("len"),
						Args: []ast.Expr{ast.NewIdent(src.Name())},
					},
				},
			},
			Post: &ast.IncDecStmt{
				X:   ast.NewIdent("i"),
				Tok: token.INC,
			},
			Body: &ast.BlockStmt{},
		}
		dstElemVar := types.NewVar(0, b.types, dst.Name()+"[i]", dstType.Elem())
		srcElemVar := types.NewVar(0, b.types, src.Name()+"[i]", srcArrType.Elem())
		elementStmt := b.buildStmt(dstElemVar, srcElemVar)
		forStmt.Body.List = append(forStmt.Body.List, elementStmt...)
		stmts = append(stmts, forStmt)
		return stmts
	case *types.Map:
		srcType, ok := src.Type().(*types.Map)
		if !ok {
			log.Printf("src type is not a map:%s", src.String())
			return append(stmts, buildCommentExpr("omit "+dst.Name()))
		}
		ifStmt := &ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X: &ast.CallExpr{
					Fun:  ast.NewIdent("len"),
					Args: []ast.Expr{ast.NewIdent(src.Name())},
				},
				OpPos: 0,
				Op:    token.GTR,
				Y:     ast.NewIdent("0"),
			},
			Body: &ast.BlockStmt{},
		}

		dstKeyVar := types.NewVar(0, b.types, "tmpK", dstType.Key())
		dstValueVar := types.NewVar(0, b.types, "tmpV", dstType.Elem())
		srcKeyVar := types.NewVar(0, b.types, "k", srcType.Key())
		srcValueVar := types.NewVar(0, b.types, "v", srcType.Elem())

		dstKeyTypeStr := b.importer.ImportType(dstKeyVar.Type())
		dstValueTypeStr := b.importer.ImportType(dstValueVar.Type())

		mkStmt := &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent(dst.Name())},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun:    ast.NewIdent("make"),
					Lparen: 0,
					Args: []ast.Expr{
						// type
						&ast.MapType{
							Key:   ast.NewIdent(dstKeyTypeStr),
							Value: ast.NewIdent(dstValueTypeStr),
						},
						// cap
						&ast.CallExpr{
							Fun:  ast.NewIdent("len"),
							Args: []ast.Expr{ast.NewIdent(src.Name())},
						},
					},
				},
			},
		}
		ifStmt.Body.List = append(ifStmt.Body.List, mkStmt)
		// for k, v := range src.xx
		rangeStmt := &ast.RangeStmt{
			Key:   ast.NewIdent("k"),
			Value: ast.NewIdent("v"),
			Tok:   token.DEFINE,
			X:     ast.NewIdent(src.Name()),
			Body:  &ast.BlockStmt{},
		}
		ifStmt.Body.List = append(ifStmt.Body.List, rangeStmt)
		kvDeclStmt := &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: []*ast.Ident{ast.NewIdent(dstKeyVar.Name())},
						Type:  ast.NewIdent(dstKeyTypeStr),
					},
					&ast.ValueSpec{
						Names: []*ast.Ident{ast.NewIdent(dstValueVar.Name())},
						Type:  ast.NewIdent(dstValueTypeStr),
					},
				},
			}}
		// var (tmpK xx, tmpV xx)
		rangeStmt.Body.List = append(rangeStmt.Body.List, kvDeclStmt)
		assignKStmt := b.buildStmt(dstKeyVar, srcKeyVar)
		assignVStmt := b.buildStmt(dstValueVar, srcValueVar)
		rangeStmt.Body.List = append(rangeStmt.Body.List, assignKStmt...)
		rangeStmt.Body.List = append(rangeStmt.Body.List, assignVStmt...)
		assignMapStmt := &ast.AssignStmt{
			Lhs: []ast.Expr{&ast.IndexExpr{
				X:      ast.NewIdent(dst.Name()),
				Lbrack: 0,
				Index:  ast.NewIdent(dstKeyVar.Name()),
				Rbrack: 0,
			}},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{ast.NewIdent(dstValueVar.Name())},
		}
		rangeStmt.Body.List = append(rangeStmt.Body.List, assignMapStmt)
		stmts = append(stmts, ifStmt)
		return stmts
	case *types.Interface:
	case *types.Slice:
		srcSliceType, _, ok := convArrayToSlice(src.Type())
		if !ok {
			log.Printf("src type is not a slice/array:%s", src.String())
			return append(stmts, buildCommentExpr("omit "+dst.Name()))
		}
		ifStmt := &ast.IfStmt{
			Cond: &ast.BinaryExpr{
				X: &ast.CallExpr{
					Fun:  ast.NewIdent("len"),
					Args: []ast.Expr{ast.NewIdent(src.Name())},
				},
				OpPos: 0,
				Op:    token.GTR,
				Y:     ast.NewIdent("0"),
			},
			Body: &ast.BlockStmt{},
		}
		mkStmt := &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent(dst.Name())},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun:    ast.NewIdent("make"),
					Lparen: 0,
					Args: []ast.Expr{
						// type
						ast.NewIdent(b.importer.ImportType(dst.Type())),
						// cap
						&ast.CallExpr{
							Fun:  ast.NewIdent("len"),
							Args: []ast.Expr{ast.NewIdent(src.Name())},
						},
					},
					Ellipsis: 0,
					Rparen:   0,
				},
			},
		}
		ifStmt.Body.List = append(ifStmt.Body.List, mkStmt)
		// for i := 0; i<n ; i++ {}
		forStmt := &ast.ForStmt{
			Init: &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("i")},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{ast.NewIdent("0")},
			},
			Cond: &ast.BinaryExpr{
				X:  ast.NewIdent("i"),
				Op: token.LSS,
				Y: &ast.CallExpr{
					Fun:  ast.NewIdent("len"),
					Args: []ast.Expr{ast.NewIdent(src.Name())},
				},
			},
			Post: &ast.IncDecStmt{
				X:   ast.NewIdent("i"),
				Tok: token.INC,
			},
			Body: &ast.BlockStmt{},
		}
		dstElemVar := types.NewVar(0, b.types, dst.Name()+"[i]", dstType.Elem())
		srcElemVar := types.NewVar(0, b.types, src.Name()+"[i]", srcSliceType.Elem())
		elementStmt := b.buildStmt(dstElemVar, srcElemVar)
		forStmt.Body.List = append(forStmt.Body.List, elementStmt...)
		ifStmt.Body.List = append(ifStmt.Body.List, forStmt)
		stmts = append(stmts, ifStmt)
		return stmts
	case *types.Named:
		dstUnderType := dstType.Underlying()
		srcUnderType := src.Type().Underlying()
		var srcName = src.Name()
		switch dstUnderType.(type) {
		case *types.Basic:
			if src.Type().String() != dst.Type().String() {
				// not same type
				srcName = fmt.Sprintf("%s(%s)", b.importer.ImportType(dst.Type()), src.Name())
			}
		}
		dstUnderVar := types.NewVar(0, b.types, dst.Name(), dstUnderType)
		srcUnderVar := types.NewVar(0, b.types, srcName, srcUnderType)
		return b.buildStmt(dstUnderVar, srcUnderVar)
	case *types.Basic:
		srcType, ok := src.Type().(*types.Basic)
		if !ok {
			underType, ok := src.Type().Underlying().(*types.Basic)
			if !ok {
				log.Printf("src type is not a basic:%s", src.String())
				return append(stmts, buildCommentExpr("omit "+dst.Name()))
			}
			// cast
			castName := fmt.Sprintf("%s(%s)", b.importer.ImportType(dst.Type()), src.Name())
			src = types.NewVar(0, b.types, castName, underType.Underlying())
			srcType = underType
		}
		if srcType.Kind() != dstType.Kind() {
			log.Printf("src type kind is not equal %s,%s", srcType.String(), dstType.String())
			return append(stmts, buildCommentExpr("omit "+dst.Name()))
		}
		var assignmentStmt = &ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent(dst.Name())},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{ast.NewIdent(src.Name())},
		}
		stmts = append(stmts, assignmentStmt)
		return stmts
	default:

	}

	return stmts
}

func (b *Builder) FillImport() {
	var importDecls []ast.Decl
	im := &ast.GenDecl{
		Doc:   nil,
		Tok:   token.IMPORT,
		Specs: []ast.Spec{},
	}
	for _, p := range b.importer.imported {
		spec := &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: "\"" + p.Path() + "\"",
			},
		}
		im.Specs = append(im.Specs, spec)
		if name, ok := b.importer.pkgToName[p.Path()]; ok && name != p.Name() {
			spec.Name = ast.NewIdent(name)
		}
	}
	importDecls = append(importDecls, im)
	b.f.Decls = append(importDecls, b.f.Decls...)
}

func buildCommentExpr(comment string) *ast.ExprStmt {
	return &ast.ExprStmt{
		X: &ast.BasicLit{
			Kind:  token.STRING,
			Value: "// " + comment,
		},
	}
}
