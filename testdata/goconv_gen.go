// Code generated by github.com/ycl2018/go-conv DO NOT EDIT.

package testdata

import (
	"github.com/ycl2018/go-conv/testdata/model"
	"github.com/ycl2018/go-conv/testdata/domain"
	domain2 "github.com/ycl2018/go-conv/testdata/model/domain"
)

func Domain2CategoryToDomainCategory(src *domain2.Category) (dst *domain.Category) {
	if src != nil {
		dst = new(domain.Category)
		dst.CategoryID = src.CategoryID
		dst.Name = src.Name
		dst.Foo = Domain2FooToDomainFoo(src.Foo)
	}
	return
}
func Domain2FooToDomainFoo(src *domain2.Foo) (dst *domain.Foo) {
	if src != nil {
		dst = new(domain.Foo)
		if src.Bar != nil {
			dst.Bar = new(string)
			*dst.Bar = *src.Bar
		}
	}
	return
}
func ModelPetToDomainEmbed(src *model.Pet) (dst *domain.Embed) {
	if src != nil {
		dst = new(domain.Embed)
		dst.C = src.C
		dst.D = src.D
	}
	return
}
func ModelPetToDomainPet(src *model.Pet) (dst *domain.Pet) {
	if src != nil {
		dst = new(domain.Pet)
		dst.ID = src.ID
		dst.Name = new(string)
		*dst.Name = src.Name
		if src.NamePtr != nil {
			dst.NamePtr = new(string)
			*dst.NamePtr = *src.NamePtr
		}
		if src.Status != nil {
			dst.Status = new(domain.PetStatus)
			*dst.Status = domain.PetStatus(*src.Status)
		}
		for i := 0; i < 3 && i < len(src.Array); i++ {
			dst.Array[i] = Domain2CategoryToDomainCategory(src.Array[i])
		}
		if len(src.Slices) > 0 {
			dst.Slices = make([]*domain.Category, len(src.Slices))
			for i := 0; i < len(src.Slices); i++ {
				dst.Slices[i] = Domain2CategoryToDomainCategory(src.Slices[i])
			}
		}
		if len(src.Maps) > 0 {
			dst.Maps = make(map[string]*domain.Category, len(src.Maps))
			for k, v := range src.Maps {
				var tmpK string
				var tmpV *domain.Category
				tmpK = k
				tmpV = Domain2CategoryToDomainCategory(v)
				dst.Maps[tmpK] = tmpV
			}
		}
		dst.Next = ModelPetToDomainPet(src.Next)
		dst.PtrToStruct.CategoryID = src.PtrToStruct.CategoryID
		dst.PtrToStruct.Name = src.PtrToStruct.Name
		dst.PtrToStruct.Foo = Domain2FooToDomainFoo(src.PtrToStruct.Foo)
		dst.StructToPtr = Domain2CategoryToDomainCategory(&src.StructToPtr)
		if len(src.SlicesStruct) > 0 {
			dst.SlicesStruct = make([]*domain.Category, len(src.SlicesStruct))
			for i := 0; i < len(src.SlicesStruct); i++ {
				dst.SlicesStruct[i] = Domain2CategoryToDomainCategory(&src.SlicesStruct[i])
			}
		}
		if len(src.SlicesPtr) > 0 {
			dst.SlicesPtr = make([]domain.Category, len(src.SlicesPtr))
			for i := 0; i < len(src.SlicesPtr); i++ {
				dst.SlicesPtr[i].CategoryID = src.SlicesPtr[i].CategoryID
				dst.SlicesPtr[i].Name = src.SlicesPtr[i].Name
				dst.SlicesPtr[i].Foo = Domain2FooToDomainFoo(src.SlicesPtr[i].Foo)
			}
		}
		for i := 0; i < 3 && i < len(src.ArrayToSlice); i++ {
			dst.ArrayToSlice[i] = Domain2CategoryToDomainCategory(src.ArrayToSlice[i])
		}
		if len(src.SliceToArray) > 0 {
			dst.SliceToArray = make([]*domain.Category, len(src.SliceToArray))
			for i := 0; i < len(src.SliceToArray); i++ {
				dst.SliceToArray[i] = Domain2CategoryToDomainCategory(src.SliceToArray[i])
			}
		}
		dst.StringConvert2 = domain.MyString(src.StringConvert2)
		dst.StringConvert = string(src.StringConvert)
		dst.NumberCast = uint64(src.NumberCast)
		dst.ByteSliceToString2 = []byte(src.ByteSliceToString2)
		dst.ByteSliceToString = string(src.ByteSliceToString)
		if len(src.MapStringString) > 0 {
			dst.MapStringString = make(map[string]string, len(src.MapStringString))
			for k, v := range src.MapStringString {
				var tmpK string
				var tmpV string
				tmpK = k
				tmpV = v
				dst.MapStringString[tmpK] = tmpV
			}
		}
		dst.A = src.A
		dst.B = src.B
		dst.Embed = ModelPetToDomainEmbed(src)
	}
	return
}
func init() {
	ModelToDomain = ModelPetToDomainPet
}
