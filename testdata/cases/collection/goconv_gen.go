// Code generated by github.com/ycl2018/go-conv DO NOT EDIT.

package collection

import (
	"github.com/ycl2018/go-conv/testdata/a"
	"github.com/ycl2018/go-conv/testdata/b"
)

func AArrayPtrToBArray(src *a.ArrayPtr) (dst *b.Array) {
	if src != nil {
		dst = new(b.Array)
		for i := 0; i < 6; i++ {
			dst.Name[i] = (*src.Name)[i]
		}
	}
	return
}
func AArrayPtrToBArrayPtr(src *a.ArrayPtr) (dst *b.ArrayPtr) {
	dst = (*b.ArrayPtr)(src)
	return
}
func AArrayPtrToBSlice(src *a.ArrayPtr) (dst *b.Slice) {
	if src != nil {
		dst = new(b.Slice)
		dst.Name = make([]string, len((*src.Name)))
		for i := 0; i < len((*src.Name)); i++ {
			dst.Name[i] = (*src.Name)[i]
		}
	}
	return
}
func AArrayPtrToBSlicePtr(src *a.ArrayPtr) (dst *b.SlicePtr) {
	if src != nil {
		dst = new(b.SlicePtr)
		if src.Name != nil {
			dst.Name = new([]string)
			*dst.Name = make([]string, len((*src.Name)))
			for i := 0; i < len((*src.Name)); i++ {
				(*dst.Name)[i] = (*src.Name)[i]
			}
		}
	}
	return
}
func AArrayToBArray(src *a.Array) (dst *b.Array) {
	dst = (*b.Array)(src)
	return
}
func AArrayToBArrayPtr(src *a.Array) (dst *b.ArrayPtr) {
	if src != nil {
		dst = new(b.ArrayPtr)
		dst.Name = new([6]string)
		*dst.Name = src.Name
	}
	return
}
func AArrayToBSlice(src *a.Array) (dst *b.Slice) {
	if src != nil {
		dst = new(b.Slice)
		dst.Name = make([]string, len(src.Name))
		for i := 0; i < len(src.Name); i++ {
			dst.Name[i] = src.Name[i]
		}
	}
	return
}
func AArrayToBSlicePtr(src *a.Array) (dst *b.SlicePtr) {
	if src != nil {
		dst = new(b.SlicePtr)
		dst.Name = new([]string)
		*dst.Name = make([]string, len(src.Name))
		for i := 0; i < len(src.Name); i++ {
			(*dst.Name)[i] = src.Name[i]
		}
	}
	return
}
func AMapPtrToBMap(src *a.MapPtr) (dst *b.Map) {
	if src != nil {
		dst = new(b.Map)
		if len((*src.Name)) > 0 {
			dst.Name = make(map[string]string, len((*src.Name)))
			for k, v := range *src.Name {
				var tmpK string
				var tmpV string
				tmpK = k
				tmpV = v
				dst.Name[tmpK] = tmpV
			}
		}
	}
	return
}
func AMapPtrToBMapPtr(src *a.MapPtr) (dst *b.MapPtr) {
	dst = (*b.MapPtr)(src)
	return
}
func AMapToBMap(src *a.Map) (dst *b.Map) {
	dst = (*b.Map)(src)
	return
}
func AMapToBMapPtr(src *a.Map) (dst *b.MapPtr) {
	if src != nil {
		dst = new(b.MapPtr)
		dst.Name = new(map[string]string)
		*dst.Name = src.Name
	}
	return
}
func ASlicePtrToBArray(src *a.SlicePtr) (dst *b.Array) {
	if src != nil {
		dst = new(b.Array)
		for i := 0; i < 6 && i < len((*src.Name)); i++ {
			dst.Name[i] = (*src.Name)[i]
		}
	}
	return
}
func ASlicePtrToBArrayPtr(src *a.SlicePtr) (dst *b.ArrayPtr) {
	if src != nil {
		dst = new(b.ArrayPtr)
		if src.Name != nil {
			dst.Name = new([6]string)
			*dst.Name = ([6]string)(*src.Name)
		}
	}
	return
}
func ASlicePtrToBSlice(src *a.SlicePtr) (dst *b.Slice) {
	if src != nil {
		dst = new(b.Slice)
		dst.Name = make([]string, len((*src.Name)))
		for i := 0; i < len((*src.Name)); i++ {
			dst.Name[i] = (*src.Name)[i]
		}
	}
	return
}
func ASlicePtrToBSlicePtr(src *a.SlicePtr) (dst *b.SlicePtr) {
	dst = (*b.SlicePtr)(src)
	return
}
func ASliceToBArray(src *a.Slice) (dst *b.Array) {
	if src != nil {
		dst = new(b.Array)
		dst.Name = ([6]string)(src.Name)
	}
	return
}
func ASliceToBArrayPtr(src *a.Slice) (dst *b.ArrayPtr) {
	if src != nil {
		dst = new(b.ArrayPtr)
		dst.Name = (*[6]string)(src.Name)
	}
	return
}
func ASliceToBSlice(src *a.Slice) (dst *b.Slice) {
	dst = (*b.Slice)(src)
	return
}
func ASliceToBSlicePtr(src *a.Slice) (dst *b.SlicePtr) {
	if src != nil {
		dst = new(b.SlicePtr)
		dst.Name = new([]string)
		*dst.Name = src.Name
	}
	return
}
func CopyAArrayPtrToBArray(src *a.ArrayPtr) (dst *b.Array) {
	if src != nil {
		dst = new(b.Array)
		for i := 0; i < 6; i++ {
			dst.Name[i] = (*src.Name)[i]
		}
	}
	return
}
func CopyAArrayPtrToBArrayPtr(src *a.ArrayPtr) (dst *b.ArrayPtr) {
	if src != nil {
		dst = new(b.ArrayPtr)
		if src.Name != nil {
			dst.Name = new([6]string)
			for i := 0; i < 6; i++ {
				(*dst.Name)[i] = (*src.Name)[i]
			}
		}
	}
	return
}
func CopyAArrayPtrToBSlice(src *a.ArrayPtr) (dst *b.Slice) {
	if src != nil {
		dst = new(b.Slice)
		dst.Name = make([]string, len((*src.Name)))
		for i := 0; i < len((*src.Name)); i++ {
			dst.Name[i] = (*src.Name)[i]
		}
	}
	return
}
func CopyAArrayPtrToBSlicePtr(src *a.ArrayPtr) (dst *b.SlicePtr) {
	if src != nil {
		dst = new(b.SlicePtr)
		if src.Name != nil {
			dst.Name = new([]string)
			*dst.Name = make([]string, len((*src.Name)))
			for i := 0; i < len((*src.Name)); i++ {
				(*dst.Name)[i] = (*src.Name)[i]
			}
		}
	}
	return
}
func CopyAArrayToBArray(src *a.Array) (dst *b.Array) {
	if src != nil {
		dst = new(b.Array)
		for i := 0; i < 6; i++ {
			dst.Name[i] = src.Name[i]
		}
	}
	return
}
func CopyAArrayToBArrayPtr(src *a.Array) (dst *b.ArrayPtr) {
	if src != nil {
		dst = new(b.ArrayPtr)
		dst.Name = new([6]string)
		for i := 0; i < 6; i++ {
			(*dst.Name)[i] = src.Name[i]
		}
	}
	return
}
func CopyAArrayToBSlice(src *a.Array) (dst *b.Slice) {
	if src != nil {
		dst = new(b.Slice)
		dst.Name = make([]string, len(src.Name))
		for i := 0; i < len(src.Name); i++ {
			dst.Name[i] = src.Name[i]
		}
	}
	return
}
func CopyAArrayToBSlicePtr(src *a.Array) (dst *b.SlicePtr) {
	if src != nil {
		dst = new(b.SlicePtr)
		dst.Name = new([]string)
		*dst.Name = make([]string, len(src.Name))
		for i := 0; i < len(src.Name); i++ {
			(*dst.Name)[i] = src.Name[i]
		}
	}
	return
}
func CopyAMapPtrToBMap(src *a.MapPtr) (dst *b.Map) {
	if src != nil {
		dst = new(b.Map)
		if len((*src.Name)) > 0 {
			dst.Name = make(map[string]string, len((*src.Name)))
			for k, v := range *src.Name {
				var tmpK string
				var tmpV string
				tmpK = k
				tmpV = v
				dst.Name[tmpK] = tmpV
			}
		}
	}
	return
}
func CopyAMapPtrToBMapPtr(src *a.MapPtr) (dst *b.MapPtr) {
	if src != nil {
		dst = new(b.MapPtr)
		if src.Name != nil {
			dst.Name = new(map[string]string)
			if len((*src.Name)) > 0 {
				*dst.Name = make(map[string]string, len((*src.Name)))
				for k, v := range *src.Name {
					var tmpK string
					var tmpV string
					tmpK = k
					tmpV = v
					(*dst.Name)[tmpK] = tmpV
				}
			}
		}
	}
	return
}
func CopyAMapToBMap(src *a.Map) (dst *b.Map) {
	if src != nil {
		dst = new(b.Map)
		if len(src.Name) > 0 {
			dst.Name = make(map[string]string, len(src.Name))
			for k, v := range src.Name {
				var tmpK string
				var tmpV string
				tmpK = k
				tmpV = v
				dst.Name[tmpK] = tmpV
			}
		}
	}
	return
}
func CopyAMapToBMapPtr(src *a.Map) (dst *b.MapPtr) {
	if src != nil {
		dst = new(b.MapPtr)
		dst.Name = new(map[string]string)
		if len(src.Name) > 0 {
			*dst.Name = make(map[string]string, len(src.Name))
			for k, v := range src.Name {
				var tmpK string
				var tmpV string
				tmpK = k
				tmpV = v
				(*dst.Name)[tmpK] = tmpV
			}
		}
	}
	return
}
func CopyASlicePtrToBArray(src *a.SlicePtr) (dst *b.Array) {
	if src != nil {
		dst = new(b.Array)
		for i := 0; i < 6 && i < len((*src.Name)); i++ {
			dst.Name[i] = (*src.Name)[i]
		}
	}
	return
}
func CopyASlicePtrToBArrayPtr(src *a.SlicePtr) (dst *b.ArrayPtr) {
	if src != nil {
		dst = new(b.ArrayPtr)
		if src.Name != nil {
			dst.Name = new([6]string)
			for i := 0; i < 6 && i < len((*src.Name)); i++ {
				(*dst.Name)[i] = (*src.Name)[i]
			}
		}
	}
	return
}
func CopyASlicePtrToBSlice(src *a.SlicePtr) (dst *b.Slice) {
	if src != nil {
		dst = new(b.Slice)
		dst.Name = make([]string, len((*src.Name)))
		for i := 0; i < len((*src.Name)); i++ {
			dst.Name[i] = (*src.Name)[i]
		}
	}
	return
}
func CopyASlicePtrToBSlicePtr(src *a.SlicePtr) (dst *b.SlicePtr) {
	if src != nil {
		dst = new(b.SlicePtr)
		if src.Name != nil {
			dst.Name = new([]string)
			*dst.Name = make([]string, len((*src.Name)))
			for i := 0; i < len((*src.Name)); i++ {
				(*dst.Name)[i] = (*src.Name)[i]
			}
		}
	}
	return
}
func CopyASliceToBArray(src *a.Slice) (dst *b.Array) {
	if src != nil {
		dst = new(b.Array)
		for i := 0; i < 6 && i < len(src.Name); i++ {
			dst.Name[i] = src.Name[i]
		}
	}
	return
}
func CopyASliceToBArrayPtr(src *a.Slice) (dst *b.ArrayPtr) {
	if src != nil {
		dst = new(b.ArrayPtr)
		dst.Name = new([6]string)
		for i := 0; i < 6 && i < len(src.Name); i++ {
			(*dst.Name)[i] = src.Name[i]
		}
	}
	return
}
func CopyASliceToBSlice(src *a.Slice) (dst *b.Slice) {
	if src != nil {
		dst = new(b.Slice)
		dst.Name = make([]string, len(src.Name))
		for i := 0; i < len(src.Name); i++ {
			dst.Name[i] = src.Name[i]
		}
	}
	return
}
func CopyASliceToBSlicePtr(src *a.Slice) (dst *b.SlicePtr) {
	if src != nil {
		dst = new(b.SlicePtr)
		dst.Name = new([]string)
		*dst.Name = make([]string, len(src.Name))
		for i := 0; i < len(src.Name); i++ {
			(*dst.Name)[i] = src.Name[i]
		}
	}
	return
}
func init() {
	ArrayPtrToArray = AArrayPtrToBArray
	ArrayPtrToArrayPtr = AArrayPtrToBArrayPtr
	ArrayPtrToSlice = AArrayPtrToBSlice
	ArrayPtrToSlicePtr = AArrayPtrToBSlicePtr
	ArrayToArray = AArrayToBArray
	ArrayToArrayPtr = AArrayToBArrayPtr
	ArrayToSlice = AArrayToBSlice
	ArrayToSlicePtr = AArrayToBSlicePtr
	CopyArrayPtrToArray = CopyAArrayPtrToBArray
	CopyArrayPtrToArrayPtr = CopyAArrayPtrToBArrayPtr
	CopyArrayPtrToSlice = CopyAArrayPtrToBSlice
	CopyArrayPtrToSlicePtr = CopyAArrayPtrToBSlicePtr
	CopyArrayToArray = CopyAArrayToBArray
	CopyArrayToArrayPtr = CopyAArrayToBArrayPtr
	CopyArrayToSlice = CopyAArrayToBSlice
	CopyArrayToSlicePtr = CopyAArrayToBSlicePtr
	CopyMapPtrToMap = CopyAMapPtrToBMap
	CopyMapPtrToMapPtr = CopyAMapPtrToBMapPtr
	CopyMapToMap = CopyAMapToBMap
	CopyMapToMapPtr = CopyAMapToBMapPtr
	CopySlicePtrToArray = CopyASlicePtrToBArray
	CopySlicePtrToArrayPtr = CopyASlicePtrToBArrayPtr
	CopySlicePtrToSlice = CopyASlicePtrToBSlice
	CopySlicePtrToSlicePtr = CopyASlicePtrToBSlicePtr
	CopySliceToArray = CopyASliceToBArray
	CopySliceToArrayPtr = CopyASliceToBArrayPtr
	CopySliceToSlice = CopyASliceToBSlice
	CopySliceToSlicePtr = CopyASliceToBSlicePtr
	MapPtrToMap = AMapPtrToBMap
	MapPtrToMapPtr = AMapPtrToBMapPtr
	MapToMap = AMapToBMap
	MapToMapPtr = AMapToBMapPtr
	SlicePtrToArray = ASlicePtrToBArray
	SlicePtrToArrayPtr = ASlicePtrToBArrayPtr
	SlicePtrToSlice = ASlicePtrToBSlice
	SlicePtrToSlicePtr = ASlicePtrToBSlicePtr
	SliceToArray = ASliceToBArray
	SliceToArrayPtr = ASliceToBArrayPtr
	SliceToSlice = ASliceToBSlice
	SliceToSlicePtr = ASliceToBSlicePtr
}
