# go-conv

![Build Status](https://github.com/ycl2018/go-conv/actions/workflows/test.yml/badge.svg?branch=main)
[![Go Report Card](https://goreportcard.com/badge/github.com/ycl2018/go-conv)](https://goreportcard.com/report/github.com/ycl2018/go-conv)


根据函数类型声明自动生成转换代码，支持转换/深拷贝模式，支持应用扩展自定义转换函数/过滤/忽略特定字段等选项

# Feature

- [x] 支持conv/deepCopy模式
- [x] 支持范型
- [x] 支持自动解指针
- [x] 支持基础类型/map/slice/array/struct 转换
- [x] 支持基础类型自动向上转型
- [x] 支持Alias类型自动转换
- [x] 支持embed field自动解包
- [x] 支持自引用对象，支持递归转换
- [x] 自动处理同名包冲突
- [x] 支持string <-> []byte/[]rune 互转
- [x] 支持Pointer <-> Struct 互转
- [x] 支持Array <-> Slice 互转
- [x] 支持扩展自定义转换/过滤/忽略选项

# Example

生成命令：

`go run github.com/ycl2018/go-conv@latest ./...`

## conv模式

conv模式是默认使用的类型转换模式，采用浅拷贝，提高转换性能

```go
// go-conv:generate
var Foo2Bar func (src *Foo) *Bar

type Foo struct {
    Str     string
    Slice   []string
    Map     map[string]string
    Pointer string
    Alias   string
}

type Bar struct {
    Str     string
    Slice   []string
    Map     map[string]string
    Pointer *string
    Alias   StringAlias
}

type StringAlias string
```

generated:

```go
// Code generated by github.com/ycl2018/go-conv DO NOT EDIT.

package testdata

func FooToBar(src *Foo) (dst *Bar) {
	if src != nil {
		dst = new(Bar)
		dst.Str = src.Str
		dst.Slice = src.Slice
		dst.Map = src.Map
		dst.Pointer = &src.Pointer
		dst.Alias = (StringAlias)(src.Alias)
	}
	return
}
func init() {
	Foo2Bar = FooToBar
}
```

## copy模式

conv模式使用深拷贝模式转换结构体的每个字段

```go
// go-conv:generate
// go-conv:copy
var Foo2Bar func(src *Foo) *Bar

type Foo struct {
	Str     string
	Slice   []string
	Map     map[string]string
	Pointer string
	Alias   string
}

type Bar struct {
	Str     string
	Slice   []string
	Map     map[string]string
	Pointer *string
	Alias   StringAlias
}

type StringAlias string
```

generated:

```go
// Code generated by github.com/ycl2018/go-conv DO NOT EDIT.

package testdata

func CopyFooToBar(src *Foo) (dst *Bar) {
	if src != nil {
		dst = new(Bar)
		dst.Str = src.Str
		if len(src.Slice) > 0 {
			dst.Slice = make([]string, len(src.Slice))
			for i := 0; i < len(src.Slice); i++ {
				dst.Slice[i] = src.Slice[i]
			}
		}
		if len(src.Map) > 0 {
			dst.Map = make(map[string]string, len(src.Map))
			for k, v := range src.Map {
				var tmpK string
				var tmpV string
				tmpK = k
				tmpV = v
				dst.Map[tmpK] = tmpV
			}
		}
		dst.Pointer = new(string)
		*dst.Pointer = src.Pointer
		dst.Alias = StringAlias(src.Alias)
	}
	return
}
func init() {
	Foo2Bar = CopyFooToBar
}
```

## 扩展选项

可使用go-conv:apply 指定要应用的配置，编程式ide友好，配置更方便

```go
// Struct2Struct conv a Basic to b Basic
// go-conv:generate
// go-conv:apply basicConvOpts
var (
	Struct2Struct func(p *a.Struct) *b.Struct
)

var basicConvOpts = []option.Option{
	// 配置忽略特定结构体的字段
	option.WithIgnoreFields(a.Struct{}, []string{"Student"}),
	// 配置在特定路径上应用的转换函数
	option.WithTransformer(transfer, "Student2.Class.Grade"),
	// 配置在特定路径上应用的过滤函数
	option.WithFilter(filter, "Student2.Teachers"),
}

func transfer(t int) string {
	return strconv.Itoa(t)
}

func filter(arr []string) []string {
	return arr
}
```

```go
// Code generated by github.com/ycl2018/go-conv DO NOT EDIT.

package cases

import (
	"github.com/ycl2018/go-conv/testdata/a"
	"github.com/ycl2018/go-conv/testdata/b"
)

func PtrAStructToPtrBStruct(src *a.Struct) (dst *b.Struct) {
	if src != nil {
		dst = new(b.Struct)
		// apply ignore option on src.Student
		dst.Student2.Name = src.Student2.Name
		dst.Student2.Class.Name = src.Student2.Class.Name
		// apply transfer option on transfer
		dst.Student2.Class.Grade = transfer(src.Student2.Class.Grade)
		// apply filter option on filter
		filteredSrcStudent2Teachers := filter(src.Student2.Teachers)
		dst.Student2.Teachers = filteredSrcStudent2Teachers
	}
	return
}
func init() {
	Struct2Struct = PtrAStructToPtrBStruct
}
```

## 更多使用实例请参考 testdata 目录